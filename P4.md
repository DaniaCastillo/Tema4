# Tema4
## P4 Modulación digital IQ
###### Gabriel Torres Garbanzo B97828
###### Isaac Stalley B97756
###### Dania Castillo Montenegro B61621
###### Grupo: 01/03

### Librerias
Para la implementación de la solución proyecto 4 se utilizaron las siguientes librerías:
- Numpy: Libreria que contiene gran cantidad de funciones matemáticas y que permite crear vectores y matrices grandes multidimensionales.
- scipy: Librería que contiene herramientas y algoritmos matematicos. En este caso se utiliza la herramienta ```fft``` para implementar la Transformada rápida de Fourier.
- matplotlib: Librería que permite generar gráficos a partir de datos contenidos en listas o arrays.
- Pillow: Librería que brinda soporte para abrir, manipular y guardar muchos formatos de archivo de imagen diferentes.
- time: módulo que proporciona varias funciones relacionadas con el tiempo.

```
# Para manipular imágenes 
from PIL import Image

# Para manipular 'arrays' de pixeles y bits, señales y operaciones
import numpy as np

# Para visualizar imágenes y señales
import matplotlib.pyplot as plt

# Para medir el tiempo de simulación
import time

# Para implementar la Transformada rápida de Fourier
from scipy import fft

```

### Extracción de los pixeles de una imagen

Para obtener la fuente de información de la imagen es necesario realizar la extracción de los pixeles de una imagen, para ello se define la función ```fuente_info``` que simula una fuente de infromación importando una imagen y retorna el resultado como un vector de pixeles, con dimensiones y canales R, G y B específicos.
```
# Se importan las librerías necesarias
from PIL import Image
import numpy as np

def fuente_info(imagen):
    '''Una función que simula una fuente de
    información al importar una imagen y 
    retornar un vector de NumPy con las 
    dimensiones de la imagen, incluidos los
    canales RGB: alto x largo x 3 canales

    :param imagen: Una imagen en formato JPG
    :return: un vector de pixeles
    '''
    img = Image.open(imagen)
    
    return np.array(img)

```

###  Codificación de pixeles a una base binaria (bits)

Cada pixel se puede codificar con un número determinadado de bits, un bit es la unidad mínima de la base binaria y toma el valor de 0 o de 1. En este caso para la codificación de pixeles a base binaria se define la función ```rgb_a_bit``` que toma el vector de pixeles RGB y lo tranforma de una base decimal a binaria, retornando un vector conformado por los canales a base 2. 

```
def rgb_a_bit(array_imagen):
    '''Convierte los pixeles de base 
    decimal (de 0 a 255) a binaria 
    (de 00000000 a 11111111).

    :param imagen: array de una imagen 
    :return: Un vector de (1 x k) bits 'int'
    '''
    # Obtener las dimensiones de la imagen
    x, y, z = array_imagen.shape
    
    # Número total de elementos (pixeles x canales)
    n_elementos = x * y * z

    # Convertir la imagen a un vector unidimensional de n_elementos
    pixeles = np.reshape(array_imagen, n_elementos)

    # Convertir los canales a base 2
    bits = [format(pixel, '08b') for pixel in pixeles]
    bits_Rx = np.array(list(''.join(bits)))
    
    return bits_Rx.astype(int)
```

### Modulación 
Para realizar el proceso de modulación se procede a definir la función ```modulador_8PSK```, en este caso se utiliza un método que simula una modulación 8-PSK, que tiene ocho símbolos posibles con tres bits *b1b2b3* que retorna la señal modulada, la potencia promedio de la señal modulada y dos señales portadoras ```cos(2πfct)``` y  ```sin(2πfct)```.


```
def modulador_8PSK(bits, fc, mpp):
    '''Un método que simula el esquema de modulación digital 8-PSK.

    :param bits: Vector unidimensional de bits
    :param fc: Frecuencia de la portadora en Hz
    :param mpp: Cantidad de muestras por periodo de onda portadora
    :return: Un vector con la señal modulada
    :return: Un valor con la potencia promedio [W]
    :return: La onda portadora1 c1(t) = cos(2πfct)
    :return: La onda portadora2 c2(t) = sin(2πfct)
    '''
    # 1. Parámetros de la 'señal' de información (bits)
    N = len(bits)  # Cantidad de bits

    # 2. Construyendo un periodo de la señal portadora c(t)
    Tc = 1 / fc  # periodo [s]
    t_periodo = np.linspace(0, Tc, mpp)  # mpp: muestras por período
    portadora1 = np.cos(2*np.pi*fc*t_periodo)  # cos(2πfct)
    portadora2 = np.sin(2*np.pi*fc*t_periodo)  # sin(2πfct)

    # 3. Inicializar la señal modulada s(t)
    t_simulacion = np.linspace(0, N*Tc, N*mpp)
    senal_Tx = np.zeros(t_simulacion.shape)

    # 4. Asignar las formas de onda según los bits (8-PSK)
    h = np.sqrt(2)/2
    for i in range(0, N, 3):
        if bits[i] == 1 and bits[i+1] == 1 and bits[i+2] == 1:
            senal_Tx[i*mpp: (i+1)*mpp] = portadora1 * 1 + portadora2 * 0

        elif bits[i] == 1 and bits[i+1] == 1 and bits[i+2] == 0:
            senal_Tx[i*mpp: (i+1)*mpp] = portadora1 * h + portadora2 * h

        elif bits[i] == 0 and bits[i+1] == 1 and bits[i+2] == 0:
            senal_Tx[i*mpp: (i+1)*mpp] = portadora1 * 0 + portadora2 * 1

        elif bits[i] == 0 and bits[i+1] == 1 and bits[i+2] == 1:
            senal_Tx[i*mpp: (i+1)*mpp] = portadora1 * -h + portadora2 * h

        elif bits[i] == 0 and bits[i+1] == 0 and bits[i+2] == 1:
            senal_Tx[i*mpp: (i+1)*mpp] = portadora1 * -1 + portadora2 * 0

        elif bits[i] == 0 and bits[i+1] == 0 and bits[i+2] == 0:
            senal_Tx[i*mpp: (i+1)*mpp] = portadora1 * -h + portadora2 * -h

        elif bits[i] == 1 and bits[i+1] == 0 and bits[i+2] == 0:
            senal_Tx[i*mpp: (i+1)*mpp] = portadora1 * 0 + portadora2 * -1

        else:
            senal_Tx[i*mpp: (i+1)*mpp] = portadora1 * h + portadora2 * -h

    # 5. Calcular la potencia promedio de la señal modulada
    Pm = (1 / (N*Tc)) * np.trapz(pow(senal_Tx, 2), t_simulacion)

    return senal_Tx, Pm, portadora1, portadora2
```

### Construcción de un canal con ruido AWGN
En una señal siempre se debe considerar el ruido, ya que este se genera debido a variables físicas cuyo comportamiento es aleatorio y distorsiona la señal transmitida. En este caso se define la función  ```canal_ruidoso```, el cual modela un medio de transmisión ruidoso empleando ruido aditivo blanco gaussiano. Esta función retorna la señal distorsionada al darse la suma de la señal transmitida con el ruido AWGN.

```
# Se importan las librerías necesarias
import numpy as np

def canal_ruidoso(senal_Tx, Pm, SNR):
    '''Un bloque que simula un medio de trans-
    misión no ideal (ruidoso) empleando ruido
    AWGN. Pide por parámetro un vector con la
    señal provieniente de un modulador y un
    valor en decibelios para la relación señal
    a ruido.

    :param senal_Tx: El vector del modulador
    :param Pm: Potencia de la señal modulada
    :param SNR: Relación señal-a-ruido en dB
    :return: La señal modulada al dejar el canal
    '''
    # Potencia del ruido generado por el canal
    Pn = Pm / pow(10, SNR/10)

    # Generando ruido auditivo blanco gaussiano (potencia = varianza)
    ruido = np.random.normal(0, np.sqrt(Pn), senal_Tx.shape)

    # Señal distorsionada por el canal ruidoso
    senal_Rx = senal_Tx + ruido

    return senal_Rx
```

